!SESSION 2020-11-26 19:30:13.048 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=pt_BR
Framework arguments:  -product org.eclipse.epp.package.committers.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.committers.product

This is a continuation of log file D:\TI02CC\ti2-cc-melg\codigo\.metadata\.bak_0.log
Created Time: 2020-11-26 20:03:31.386

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:31.402
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:31.419
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:34.476
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:34.495
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:34.512
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:36.029
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:36.059
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:36.077
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:36.872
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:36.894
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:36.914
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:36.970
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:36.993
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:37.029
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:38.487
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:38.509
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:38.525
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:39.535
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:39.556
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:39.573
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:40.568
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:40.592
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:40.610
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:44.378
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor54.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:44.400
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor54.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:44.421
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor54.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:44.637
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:44.661
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:44.682
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:46.509
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:46.532
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:46.549
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:47.209
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:47.230
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:47.248
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:49.288
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = \"+avaliacao.getCandidaturaId()+\"");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-26 20:03:49.310
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-26 20:03:49.329
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:49.390
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = \"+avaliacao.getCandidaturaId()+\"");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:49.412
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:49.431
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:53.115
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = \"+avaliacao.getCandidaturaId()+\"");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:53.135
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:53.152
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:58.450
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-26 20:03:58.470
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-26 20:03:58.488
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:03:58.569
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:03:58.589
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:03:58.695
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:00.547
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-26 20:04:00.564
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-26 20:04:00.580
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:05.537
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:05.560
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:05.579
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:10.349
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:10.371
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:10.388
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:41.221
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-26 20:04:41.244
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-26 20:04:41.260
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:41.324
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:41.333
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:41.341
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:42.738
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:42.760
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:42.778
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:43.557
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:43.654
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:43.665
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:45.476
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:45.497
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:45.515
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:46.363
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:46.384
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:46.401
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:46.588
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:46.609
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:46.626
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:51.337
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:51.358
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:51.374
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:55.537
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:55.548
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:55.556
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:04:59.135
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:04:59.155
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:04:59.173
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:05:08.882
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:05:08.894
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:05:08.903
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:05:25.582
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-26 20:05:25.605
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-26 20:05:25.620
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-26 20:05:32.421
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package com.ti2cc;

import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.JsonArray;

import Classes.Avaliacao;
import Classes.Avaliacoes;
import Classes.Candidato;
import Classes.Candidatura;
import Classes.Usuario;
import spark.Request;
import spark.Response;


public class DAO {
	private Connection conexao;
	
	public DAO() {
		conexao = null;
	}
	
	public boolean conectar() {
		String driverName = "org.postgresql.Driver";                    
		String serverName = "localhost";
		String mydatabase = "trabalho";
		int porta = 5432;
		String url = "jdbc:postgresql://" + serverName + ":" + porta +"/" + mydatabase;
		String username = "postgres";
		String password = "ti@cc";
		boolean status = false;

		try {
			Class.forName(driverName);
			conexao = DriverManager.getConnection(url, username, password);
			status = (conexao == null);
			System.out.println("ConexÃ£o efetuada com o postgres!");
		} catch (ClassNotFoundException e) { 
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- Driver nÃ£o encontrado -- " + e.getMessage());
		} catch (SQLException e) {
			System.err.println("ConexÃ£o NÃƒO efetuada com o postgres -- " + e.getMessage());
		}

		return status;
	}
	
	public boolean close() {
		boolean status = false;
		
		try {
			conexao.close();
			status = true;
		} catch (SQLException e) {
			System.err.println(e.getMessage());
		}
		return status;
	}
	
	
	/*INICIO DENUNCIA*/
	
	
	//INICIO --------------- POST INSERIR
	public String inserirDenuncia(Request request, Response response) {
		
		int id = 1;
		String acusado = request.queryParams("acusado");
		int quantidade = 1;
		int id_usuario = 1;
		//int quantidade = Integer.parseInt(request.queryParams("quantidade"));
		//int id_usuario = Integer.parseInt(request.queryParams("id_usuario"));

		

		Denuncia denuncia = new Denuncia(id, acusado, quantidade, id_usuario);

		inserirDenuncia(denuncia);

		response.status(201); // 201 Created
		return "Inserido com Sucesso! Acusado " + acusado;
	}
	
	public boolean inserirDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO denuncias (id, acusado, quantidade, id_usuario) "
					       + "VALUES ("+denuncia.getId()+ ", '" + denuncia.getAcusado() + "', '"  
					       + denuncia.getQuantidade() + "', '" + denuncia.getId_usuario() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	//FIM --------------- POST INSERIR
	
	
	
	//INICIO --------------- NEXT ID	
	public int nextIdAvaliacao() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_avaliacao FROM \"Avaliacao\" ORDER BY id_avaliacao DESC LIMIT 1;");	
			
			if(rs.next()){
				tmp = rs.getInt("id_avaliacao");
	          }
			st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	
	public int nextIdUsuario() {
		int tmp = -1;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT id_usuario FROM \"Usuario\" ORDER BY id_usuario DESC LIMIT 1;");	
			if(rs.next()){
				tmp = rs.getInt("id_usuario");
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return tmp+1;
	}
	//FIM --------------- NEXT ID
	
	
	//INICIO --------------- GET ALl cidades
			public String buscarCidadesDoEstado(Request request, Response response) throws JsonProcessingException {
			    response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				response.status(200); 
				String array[] = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					
					ResultSet rs = st.executeQuery("SELECT cidade\r\n" + 
							"FROM \"Candidatura\" \r\n" + 
							"WHERE uf = '"+request.queryParams("estado")+"'\r\n" + 
							"GROUP BY cidade");	
					System.out.println(request.queryParams("estado"));
			         if(rs.next()){
			        	 System.out.println("entrei");
			             rs.last();
			              array = new String[rs.getRow()];
			             rs.beforeFirst();

			             for(int i = 0; rs.next(); i++) {
			            	 array[i] = rs.getString("cidade");
			            	 System.out.println(array[i]);
			             }
			             
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(array);
				return jsonString;
			}
			
			//FIM --------------- GET ALL CIDADES
			
			
			
	
			
			
	//INICIO --------------- GET ALL	 POR CIDADE
		public Object buscarCandidadosPorCidade(Request request, Response response) throws JsonProcessingException {
			

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
			response.status(200); 
			
			Candidatura[] candidatura = null;
			
			try {
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				
				ResultSet rs = st.executeQuery("\r\n" + 
						"select * from\r\n" + 
						"\r\n" + 
						"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.comentario IS NOT NULL\r\n" + 
						"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
						"\r\n" + 
						"RIGHT JOIN (select * from\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(select * from\r\n" + 
						"\r\n" + 
						"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
						"\r\n" + 
						"FROM \r\n" + 
						"(SELECT *\r\n" + 
						"FROM \r\n" + 
						" \r\n" + 
						"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
						" \r\n" + 
						"INNER JOIN \r\n" + 
						"(SELECT * \r\n" + 
						"FROM \r\n" + 
						"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
						"FROM \"Avaliacao\" A\r\n" + 
						"WHERE A.nao_gostei = true\r\n" + 
						"GROUP BY A.\"candidatura_id\") A\r\n" + 
						"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
						" \r\n" + 
						"on LK.id = DLK.id\r\n" + 
						"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
						"Avaliacoes\r\n" + 
						"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
						"\r\n" + 
						"Candidatura\r\n" + 
						"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
						"Tudo\r\n" + 
						"\r\n" + 
						"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
						"WHERE usuario_id_usuario = '"+request.queryParams("idUsuario")+"' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
						"\r\n" + 
						" WHERE cidade = '"+request.queryParams("cidade")+"' AND uf='"+request.queryParams("estado")+"'");
				
		         if(rs.next()){
		             rs.last();
		             candidatura = new Candidatura[rs.getRow()];
		             rs.beforeFirst();

		             for(int i = 0; rs.next(); i++) {
		            	 Candidato candidato = new Candidato( rs.getString("cpf"),  rs.getString("nome"),  rs.getString("email"),  rs.getString("nome_urna"),  rs.getString("nascionalidade"),  rs.getString("municipio_nascimento"),  rs.getString("idade"),  rs.getString("uf_nascimento"),  rs.getString("genero"),  rs.getString("ocupacao"),  rs.getString("grau_instrucao"));
		            	 Avaliacoes avaliacao = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
		            	 System.out.println(avaliacao.toString());
		            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getBoolean("liked"), rs.getBoolean("desliked"), candidato, avaliacao);
		            	 System.out.println(candidatura[i].toString());
		             }
		             
		          }
		          st.close();
			} catch (Exception e) {
				System.err.println(e.getMessage());
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(candidatura);
			return jsonString;
		}
	//FIM --------------- GET ALL POR CIDADE
	
	
	//INICIO --------------- POST FAZER LOGIN
		public Object login(Request request, Response response) throws JsonProcessingException {

		    response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
		    
		    
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");
			
			Usuario usuario = new Usuario(-1, userName, senha);

			response.status(200); 

			return login(usuario);
		}
		
		
		public Object login(Usuario usuario) throws JsonProcessingException {
			Usuario tmp = usuario;
			try {  				
				Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
				ResultSet rs = st.executeQuery("SELECT * FROM \"Usuario\"\r\n" + 
						"WHERE usuario = '"+usuario.getUsuario()+"' and senha = '"+usuario.getSenha()+"'");
				st.close();
				
				if(rs.next()) {
					tmp = new Usuario(rs.getInt("id_usuario"), rs.getString("usuario"), rs.getString("senha"));
				}
				
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(tmp);
			return jsonString;
		}
	//FIM --------------- POST FAZER LOGIN
			
			
	
		
	//INICIO --------------- POST DAR LIKE
			public String tentativaAvaliacao(Request request, Response response) throws JsonProcessingException {
				//resolver unique userName;
				
				response.header("Access-Control-Allow-Origin", "*");
			    response.header("Content-Type", "application/json");
				
				int idAvaliacao = nextIdAvaliacao();
				String candidaturaId = request.queryParams("candidaturaId");
				System.out.println("candidaturaId"+candidaturaId);
				String usuarioId = request.queryParams("usuarioId");
				System.out.println("usuarioId"+usuarioId);
				boolean like = Boolean.parseBoolean(request.queryParams("like"));
				boolean deslike = Boolean.parseBoolean(request.queryParams("deslike"));				
				
				Avaliacao avaliacao = new Avaliacao(idAvaliacao, like, deslike, Integer.parseInt(candidaturaId ), Integer.parseInt(usuarioId), null);
				
				boolean status = false;
				if(verificarSeJaAvaliei(avaliacao) == true) {
					status = atualizarVoto(avaliacao);
				}else {
					status = avaliar(avaliacao);
				}
				
				Avaliacoes avaliacoes = buscarAvaliacoes(avaliacao,  request.queryParams("cidade"),  request.queryParams("estado"));
				
				

				if(status) {
					response.status(200);
				}else {
					response.status(400);
					avaliacao.setId(-1);
				}
				

				ObjectMapper mapper = new ObjectMapper();
				String jsonString = mapper.writeValueAsString(avaliacoes);
				return jsonString;
				
			}
			
			
			public Avaliacoes buscarAvaliacoes(Avaliacao avaliacao, String cidade, String estado) {
				Avaliacoes avaliacoes = null;
				try {
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("\r\n" + 
							"select cpf, lk, dlk, qtdcmts,id from\r\n" + 
							"\r\n" + 
							"((SELECT A.\"candidatura_id\", count(comentario) AS qtdcmts\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.comentario IS NOT NULL\r\n" + 
							"GROUP BY A.\"candidatura_id\")) qtdavaliacao\r\n" + 
							"\r\n" + 
							"RIGHT JOIN (select * from\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(select * from\r\n" + 
							"\r\n" + 
							"(SELECT DLK.id AS codigo, DLK dlk, LK lk\r\n" + 
							"\r\n" + 
							"FROM \r\n" + 
							"(SELECT *\r\n" + 
							"FROM \r\n" + 
							" \r\n" + 
							"(SELECT A.\"candidatura_id\", count(gostei) AS lk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) LK\r\n" + 
							" \r\n" + 
							"INNER JOIN \r\n" + 
							"(SELECT * \r\n" + 
							"FROM \r\n" + 
							"(SELECT A.\"candidatura_id\", count(nao_gostei) AS dlk\r\n" + 
							"FROM \"Avaliacao\" A\r\n" + 
							"WHERE A.nao_gostei = true\r\n" + 
							"GROUP BY A.\"candidatura_id\") A\r\n" + 
							"RIGHT JOIN \"Candidatura\" C ON A.\"candidatura_id\" = C.id) DLK \r\n" + 
							" \r\n" + 
							"on LK.id = DLK.id\r\n" + 
							"GROUP BY DLK.id, DLK.dlk, LK.lk) \r\n" + 
							"Avaliacoes\r\n" + 
							"RIGHT JOIN \"Candidatura\" C on Avaliacoes.codigo = C.id)\r\n" + 
							"\r\n" + 
							"Candidatura\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\")\r\n" + 
							"Tudo\r\n" + 
							"\r\n" + 
							"LEFT JOIN (SELECT nao_gostei as desliked, gostei as liked, candidatura_id FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '3' ) DLKED on Tudo.id = DLKED.candidatura_id) Z on Z.id = qtdavaliacao.candidatura_id\r\n" + 
							"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"'");
					
					
					
							"\r\n" + 
							"\r\n" + 
							"INNER JOIN \"Candidato\" C ON Candidatura.\"Candidato_cpf\" = C.\"cpf\"\r\n" + 
							" WHERE cidade = '"+cidade+"' AND uf='"+estado+"' AND id = "+avaliacao.getCandidaturaId()+"");	
			         

		             if(rs.next()){
			             rs.last();
			             rs.beforeFirst();
			             for(int i = 0; rs.next(); i++) {
			            	 avaliacoes = new Avaliacoes(rs.getString("cpf"), rs.getInt("lk"), rs.getInt("dlk"),rs.getInt("qtdcmts"), rs.getInt("id"));
			             }
			          }
			          st.close();
				} catch (Exception e) {System.err.println(e.getMessage());}
				return avaliacoes;
			}
			
			
			public boolean atualizarVoto(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("UPDATE \"Avaliacao\"\r\n" + 
							"SET nao_gostei = "+avaliacao.isNaoGostei()+", gostei= "+avaliacao.isGostei()+"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				return status;
			}
			
			public boolean avaliar(Avaliacao avaliacao) throws JsonProcessingException {
				boolean status = false;
				try {  
					Statement st = conexao.createStatement();
					st.executeUpdate("insert into \"Avaliacao\" (id_avaliacao, gostei, nao_gostei, candidatura_id, usuario_id_usuario) VALUES ("+
					avaliacao.getId()+","
							+ avaliacao.isGostei() +","
									+ avaliacao.isNaoGostei()+","
											+ avaliacao.getCandidaturaId()+","
													+ avaliacao.getUsuarioId()+")");
					System.out.println(st);
					st.close();
					status = true;
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				
				
				return status;
			}
			public boolean verificarSeJaAvaliei(Avaliacao avaliacao) {
				boolean status = false;
				try {  
					
					Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
					ResultSet rs = st.executeQuery("SELECT * FROM \"Avaliacao\"\r\n" + 
							"WHERE usuario_id_usuario = '"+avaliacao.getUsuarioId()+"' AND candidatura_id = '"+avaliacao.getCandidaturaId()+"'");		
			        
					if(rs.next()){
						status = true;
					}else {
						status = false;
					}
					st.close();
				} catch (SQLException u) {  
					throw new RuntimeException(u);
				}
				return status;
			}
			
			
		//FIM --------------- POST DAR LIKE
			
			
	
	
	
	//INICIO --------------- POST INSERIR USUARIO
		public String adicionarUsuario(Request request, Response response) throws JsonProcessingException {
			//resolver unique userName;
			
			response.header("Access-Control-Allow-Origin", "*");
		    response.header("Content-Type", "application/json");
			
			int idUsuario = nextIdUsuario();
			String userName = request.queryParams("usuario");
			String senha = request.queryParams("senha");

			

			Usuario usuario = new Usuario(idUsuario, userName, senha);


			if(adicionarUsuario(usuario)) {
				response.status(200);
			}else {
				response.status(400);
				usuario.setIdUsuario(-1);				
			}

			
			ObjectMapper mapper = new ObjectMapper();
			String jsonString = mapper.writeValueAsString(usuario);
			
			
			return jsonString;
		}
		
		
		public boolean adicionarUsuario(Usuario usuario) {
			boolean status = false;
			try {  
				Statement st = conexao.createStatement();
				st.executeUpdate("INSERT INTO \"Usuario\" (id_usuario, usuario, senha) "
						       + "VALUES (" + usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
						       + usuario.getSenha() + "');");
				st.close();
				status = true;
			} catch (SQLException u) {  
				throw new RuntimeException(u);
			}
			return status;
		}
	//FIM --------------- POST INSERIR USUARIO
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	//INICIO --------------- GET ALL	
	/*public Object getCandidaturas(Request request, Response response) {
		StringBuffer returnValue = new StringBuffer("<candidaturas type=\"array\">");
		for (Candidatura candidatura : getCandidaturas()) {
			returnValue.append("\n<candidatura>\n" + 
            		"\t<id> " + candidatura.getId() + "</id>\n" +
            		"</candidatura>\n");
		}
		returnValue.append("</candidaturas>");
	    response.header("Content-Type", "application/xml");
	    response.header("Content-Encoding", "UTF-8");
		return returnValue.toString();
	}
	
	
	public Candidatura[] getCandidaturas() {
		Candidatura[] candidatura = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			
			ResultSet rs = st.executeQuery("SELECT * FROM \"Candidatura\"");		
	         if(rs.next()){
	             rs.last();
	             candidatura = new Candidatura[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	            	 candidatura[i] = new Candidatura(rs.getInt("id"), rs.getString("ano"), rs.getString("cidade"), rs.getString("uf"), rs.getString("cargo"), rs.getString("partido_composicao"), rs.getInt("dispesa_max"), rs.getString("Candidato_cpf"));
	             }
	             
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return candidatura;
	}*/
	//FIM --------------- GET ALL	
	
	
	
	
	
	
	public boolean atualizarDenuncia(Denuncia denuncia) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE denuncias SET acusado = '" + denuncia.getAcusado()+ "', quantidade = '"  
				       + denuncia.getQuantidade() 
					   + " WHERE id = " + denuncia.getId();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirDenuncia(int id) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM denuncias WHERE id = " + id);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	/*FIM DENUNCIA*/
	
	
	
	
	public boolean inserirUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("INSERT INTO usuario (codigo, login, senha, sexo) "
					       + "VALUES ("+usuario.getIdUsuario()+ ", '" + usuario.getUsuario() + "', '"  
					       + usuario.getSenha() + "');");
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean atualizarUsuario(Usuario usuario) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			String sql = "UPDATE usuario SET login = '" + usuario.getUsuario() + "', senha = '"  
				       + usuario.getSenha()
					   + " WHERE codigo = " + usuario.getIdUsuario();
			st.executeUpdate(sql);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	public boolean excluirUsuario(int codigo) {
		boolean status = false;
		try {  
			Statement st = conexao.createStatement();
			st.executeUpdate("DELETE FROM usuario WHERE codigo = " + codigo);
			st.close();
			status = true;
		} catch (SQLException u) {  
			throw new RuntimeException(u);
		}
		return status;
	}
	
	
	public Usuario[] getUsuarios() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
	                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
	                		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}

	
	public Usuario[] getUsuariosMasculinos() {
		Usuario[] usuarios = null;
		
		try {
			Statement st = conexao.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);
			ResultSet rs = st.executeQuery("SELECT * FROM usuario WHERE usuario.sexo LIKE 'M'");		
	         if(rs.next()){
	             rs.last();
	             usuarios = new Usuario[rs.getRow()];
	             rs.beforeFirst();

	             for(int i = 0; rs.next(); i++) {
		                usuarios[i] = new Usuario(rs.getInt("codigo"), rs.getString("login"), 
                         		                  rs.getString("senha"));
	             }
	          }
	          st.close();
		} catch (Exception e) {
			System.err.println(e.getMessage());
		}
		return usuarios;
	}
}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-26 20:05:32.440
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2986)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
